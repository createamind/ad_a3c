// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.0
//
// <auto-generated>
//
// Generated from file `data.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <data.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <Ice/LocalException.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 0
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::DataFlow::NDArray> iceC_DataFlow_NDArray_init("::DataFlow::NDArray");

const ::IceInternal::DefaultValueFactoryInit<::DataFlow::IOData> iceC_DataFlow_IOData_init("::DataFlow::IOData");

const ::IceInternal::DefaultValueFactoryInit<::DataFlow::IODataPut> iceC_DataFlow_IODataPut_init("::DataFlow::IODataPut");

const ::IceInternal::DefaultValueFactoryInit<::DataFlow::IODataGet> iceC_DataFlow_IODataGet_init("::DataFlow::IODataGet");

const ::IceInternal::DefaultValueFactoryInit<::DataFlow::IOStreamParam> iceC_DataFlow_IOStreamParam_init("::DataFlow::IOStreamParam");

const ::std::string iceC_DataFlow_IOStream_ids[2] =
{
    "::DataFlow::IOStream",
    "::Ice::Object"
};
const ::std::string iceC_DataFlow_IOStream_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

const ::IceInternal::DefaultValueFactoryInit<::DataFlow::ObjectBase> iceC_DataFlow_ObjectBase_init("::DataFlow::ObjectBase");

const ::IceInternal::DefaultValueFactoryInit<::DataFlow::InitServerParams> iceC_DataFlow_InitServerParams_init("::DataFlow::InitServerParams");

const ::IceInternal::DefaultValueFactoryInit<::DataFlow::DSStatus> iceC_DataFlow_DSStatus_init("::DataFlow::DSStatus");

const ::IceInternal::DefaultValueFactoryInit<::DataFlow::BatchDataProcessorStatus> iceC_DataFlow_BatchDataProcessorStatus_init("::DataFlow::BatchDataProcessorStatus");

const ::IceInternal::DefaultUserExceptionFactoryInit<::DataFlow::ExceptionClosed> iceC_DataFlow_ExceptionClosed_init("::DataFlow::ExceptionClosed");

const ::std::string iceC_DataFlow_DataServer_ids[2] =
{
    "::DataFlow::DataServer",
    "::Ice::Object"
};
const ::std::string iceC_DataFlow_DataServer_ops[] =
{
    "getBatchDataProcessorStatus",
    "getData",
    "getStatus",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "init",
    "putData"
};
const ::std::string iceC_DataFlow_DataServer_init_name = "init";
const ::std::string iceC_DataFlow_DataServer_getStatus_name = "getStatus";
const ::std::string iceC_DataFlow_DataServer_getBatchDataProcessorStatus_name = "getBatchDataProcessorStatus";
const ::std::string iceC_DataFlow_DataServer_putData_name = "putData";
const ::std::string iceC_DataFlow_DataServer_getData_name = "getData";

const ::IceInternal::DefaultValueFactoryInit<::DataFlow::EvtEpoch> iceC_DataFlow_EvtEpoch_init("::DataFlow::EvtEpoch");

const ::std::string iceC_DataFlow_BatchDataProcessor_ids[2] =
{
    "::DataFlow::BatchDataProcessor",
    "::Ice::Object"
};
const ::std::string iceC_DataFlow_BatchDataProcessor_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "onEvent"
};
const ::std::string iceC_DataFlow_BatchDataProcessor_onEvent_name = "onEvent";

}

DataFlow::ExceptionClosed::~ExceptionClosed()
{
}

const ::std::string&
DataFlow::ExceptionClosed::ice_staticId()
{
    static const ::std::string typeId = "::DataFlow::ExceptionClosed";
    return typeId;
}

bool
DataFlow::IOStream::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_IOStream_ids, iceC_DataFlow_IOStream_ids + 2, s);
}

::std::vector<::std::string>
DataFlow::IOStream::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_DataFlow_IOStream_ids[0], &iceC_DataFlow_IOStream_ids[2]);
}

::std::string
DataFlow::IOStream::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::IOStream::ice_staticId()
{
    static const ::std::string typeId = "::DataFlow::IOStream";
    return typeId;
}

bool
DataFlow::DataServer::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_DataServer_ids, iceC_DataFlow_DataServer_ids + 2, s);
}

::std::vector<::std::string>
DataFlow::DataServer::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_DataFlow_DataServer_ids[0], &iceC_DataFlow_DataServer_ids[2]);
}

::std::string
DataFlow::DataServer::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::DataServer::ice_staticId()
{
    static const ::std::string typeId = "::DataFlow::DataServer";
    return typeId;
}

bool
DataFlow::DataServer::_iceD_init(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<::DataFlow::InitServerParams> iceP_params;
    istr->readAll(iceP_params);
    istr->readPendingValues();
    inS.endReadParams();
    this->init(::std::move(iceP_params), current);
    inS.writeEmptyParams();
    return true;
}

bool
DataFlow::DataServer::_iceD_getStatus(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::shared_ptr<::DataFlow::DSStatus> ret = this->getStatus(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}

bool
DataFlow::DataServer::_iceD_getBatchDataProcessorStatus(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    int iceP_processorIdx;
    istr->readAll(iceP_name, iceP_processorIdx);
    inS.endReadParams();
    ::std::shared_ptr<::DataFlow::BatchDataProcessorStatus> ret = this->getBatchDataProcessorStatus(::std::move(iceP_name), iceP_processorIdx, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}

bool
DataFlow::DataServer::_iceD_putData(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<::DataFlow::IODataPut> iceP_data;
    istr->readAll(iceP_data);
    istr->readPendingValues();
    inS.endReadParams();
    this->putData(::std::move(iceP_data), current);
    inS.writeEmptyParams();
    return true;
}

bool
DataFlow::DataServer::_iceD_getData(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    int iceP_processorIdx;
    istr->readAll(iceP_name, iceP_processorIdx);
    inS.endReadParams();
    ::std::shared_ptr<::DataFlow::IODataGet> ret = this->getData(::std::move(iceP_name), iceP_processorIdx, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}

bool
DataFlow::DataServer::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_DataFlow_DataServer_ops, iceC_DataFlow_DataServer_ops + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_DataFlow_DataServer_ops)
    {
        case 0:
        {
            return _iceD_getBatchDataProcessorStatus(in, current);
        }
        case 1:
        {
            return _iceD_getData(in, current);
        }
        case 2:
        {
            return _iceD_getStatus(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_init(in, current);
        }
        case 8:
        {
            return _iceD_putData(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}

bool
DataFlow::BatchDataProcessor::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_BatchDataProcessor_ids, iceC_DataFlow_BatchDataProcessor_ids + 2, s);
}

::std::vector<::std::string>
DataFlow::BatchDataProcessor::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_DataFlow_BatchDataProcessor_ids[0], &iceC_DataFlow_BatchDataProcessor_ids[2]);
}

::std::string
DataFlow::BatchDataProcessor::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::BatchDataProcessor::ice_staticId()
{
    static const ::std::string typeId = "::DataFlow::BatchDataProcessor";
    return typeId;
}

bool
DataFlow::BatchDataProcessor::_iceD_onEvent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::DataFlow::EventParamMap iceP_params;
    istr->readAll(iceP_params);
    istr->readPendingValues();
    inS.endReadParams();
    this->onEvent(::std::move(iceP_params), current);
    inS.writeEmptyParams();
    return true;
}

bool
DataFlow::BatchDataProcessor::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_DataFlow_BatchDataProcessor_ops, iceC_DataFlow_BatchDataProcessor_ops + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_DataFlow_BatchDataProcessor_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_onEvent(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}

DataFlow::NDArray::~NDArray()
{
}

const ::std::string&
DataFlow::NDArray::ice_staticId()
{
    static const ::std::string typeId = "::DataFlow::NDArray";
    return typeId;
}

DataFlow::IOData::~IOData()
{
}

const ::std::string&
DataFlow::IOData::ice_staticId()
{
    static const ::std::string typeId = "::DataFlow::IOData";
    return typeId;
}

DataFlow::IODataPut::~IODataPut()
{
}

const ::std::string&
DataFlow::IODataPut::ice_staticId()
{
    static const ::std::string typeId = "::DataFlow::IODataPut";
    return typeId;
}

DataFlow::IODataGet::~IODataGet()
{
}

const ::std::string&
DataFlow::IODataGet::ice_staticId()
{
    static const ::std::string typeId = "::DataFlow::IODataGet";
    return typeId;
}

DataFlow::IOStreamParam::~IOStreamParam()
{
}

const ::std::string&
DataFlow::IOStreamParam::ice_staticId()
{
    static const ::std::string typeId = "::DataFlow::IOStreamParam";
    return typeId;
}

DataFlow::ObjectBase::~ObjectBase()
{
}

const ::std::string&
DataFlow::ObjectBase::ice_staticId()
{
    static const ::std::string typeId = "::DataFlow::ObjectBase";
    return typeId;
}

DataFlow::InitServerParams::~InitServerParams()
{
}

const ::std::string&
DataFlow::InitServerParams::ice_staticId()
{
    static const ::std::string typeId = "::DataFlow::InitServerParams";
    return typeId;
}

DataFlow::DSStatus::~DSStatus()
{
}

const ::std::string&
DataFlow::DSStatus::ice_staticId()
{
    static const ::std::string typeId = "::DataFlow::DSStatus";
    return typeId;
}

DataFlow::BatchDataProcessorStatus::~BatchDataProcessorStatus()
{
}

const ::std::string&
DataFlow::BatchDataProcessorStatus::ice_staticId()
{
    static const ::std::string typeId = "::DataFlow::BatchDataProcessorStatus";
    return typeId;
}

DataFlow::EvtEpoch::~EvtEpoch()
{
}

const ::std::string&
DataFlow::EvtEpoch::ice_staticId()
{
    static const ::std::string typeId = "::DataFlow::EvtEpoch";
    return typeId;
}

::std::shared_ptr<::Ice::ObjectPrx>
DataFlow::IOStreamPrx::_newInstance() const
{
    return ::IceInternal::createProxy<IOStreamPrx>();
}

const ::std::string&
DataFlow::IOStreamPrx::ice_staticId()
{
    return DataFlow::IOStream::ice_staticId();
}

void
DataFlow::DataServerPrx::_iceI_init(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<::DataFlow::InitServerParams>& iceP_params, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_DataFlow_DataServer_init_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_params);
            ostr->writePendingValues();
        },
        nullptr);
}

void
DataFlow::DataServerPrx::_iceI_getStatus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::DataFlow::DSStatus>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_DataFlow_DataServer_getStatus_name);
    outAsync->invoke(iceC_DataFlow_DataServer_getStatus_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<::DataFlow::DSStatus> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

void
DataFlow::DataServerPrx::_iceI_getBatchDataProcessorStatus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::DataFlow::BatchDataProcessorStatus>>>& outAsync, const ::std::string& iceP_name, int iceP_processorIdx, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_DataFlow_DataServer_getBatchDataProcessorStatus_name);
    outAsync->invoke(iceC_DataFlow_DataServer_getBatchDataProcessorStatus_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_processorIdx);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<::DataFlow::BatchDataProcessorStatus> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

void
DataFlow::DataServerPrx::_iceI_putData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<::DataFlow::IODataPut>& iceP_data, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_DataFlow_DataServer_putData_name);
    outAsync->invoke(iceC_DataFlow_DataServer_putData_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_data);
            ostr->writePendingValues();
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ::DataFlow::ExceptionClosed&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
DataFlow::DataServerPrx::_iceI_getData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::DataFlow::IODataGet>>>& outAsync, const ::std::string& iceP_name, int iceP_processorIdx, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_DataFlow_DataServer_getData_name);
    outAsync->invoke(iceC_DataFlow_DataServer_getData_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_processorIdx);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ::DataFlow::ExceptionClosed&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<::DataFlow::IODataGet> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::std::shared_ptr<::Ice::ObjectPrx>
DataFlow::DataServerPrx::_newInstance() const
{
    return ::IceInternal::createProxy<DataServerPrx>();
}

const ::std::string&
DataFlow::DataServerPrx::ice_staticId()
{
    return DataFlow::DataServer::ice_staticId();
}

void
DataFlow::BatchDataProcessorPrx::_iceI_onEvent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::DataFlow::EventParamMap& iceP_params, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_DataFlow_BatchDataProcessor_onEvent_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_params);
            ostr->writePendingValues();
        },
        nullptr);
}

::std::shared_ptr<::Ice::ObjectPrx>
DataFlow::BatchDataProcessorPrx::_newInstance() const
{
    return ::IceInternal::createProxy<BatchDataProcessorPrx>();
}

const ::std::string&
DataFlow::BatchDataProcessorPrx::ice_staticId()
{
    return DataFlow::BatchDataProcessor::ice_staticId();
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_DataFlow_DataServer_init_name = "init";

const ::std::string iceC_DataFlow_DataServer_getStatus_name = "getStatus";

const ::std::string iceC_DataFlow_DataServer_getBatchDataProcessorStatus_name = "getBatchDataProcessorStatus";

const ::std::string iceC_DataFlow_DataServer_putData_name = "putData";

const ::std::string iceC_DataFlow_DataServer_getData_name = "getData";

const ::std::string iceC_DataFlow_BatchDataProcessor_onEvent_name = "onEvent";

}

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::DataFlow::ExceptionClosed> iceC_DataFlow_ExceptionClosed_init("::DataFlow::ExceptionClosed");

}

DataFlow::ExceptionClosed::~ExceptionClosed() throw()
{
}

::std::string
DataFlow::ExceptionClosed::ice_id() const
{
    return "::DataFlow::ExceptionClosed";
}

DataFlow::ExceptionClosed*
DataFlow::ExceptionClosed::ice_clone() const
{
    return new ExceptionClosed(*this);
}

void
DataFlow::ExceptionClosed::ice_throw() const
{
    throw *this;
}

void
DataFlow::ExceptionClosed::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::DataFlow::ExceptionClosed", -1, true);
    Ice::StreamWriter< ::DataFlow::ExceptionClosed, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
DataFlow::ExceptionClosed::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::DataFlow::ExceptionClosed, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
::IceProxy::Ice::Object* ::IceProxy::DataFlow::upCast(::IceProxy::DataFlow::NDArray* p) { return p; }

void
::IceProxy::DataFlow::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::NDArray>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::DataFlow::NDArray;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::DataFlow::NDArray::_newInstance() const
{
    return new NDArray;
}

const ::std::string&
IceProxy::DataFlow::NDArray::ice_staticId()
{
    return ::DataFlow::NDArray::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::DataFlow::upCast(::IceProxy::DataFlow::IOData* p) { return p; }

void
::IceProxy::DataFlow::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IOData>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::DataFlow::IOData;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::DataFlow::IOData::_newInstance() const
{
    return new IOData;
}

const ::std::string&
IceProxy::DataFlow::IOData::ice_staticId()
{
    return ::DataFlow::IOData::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::DataFlow::upCast(::IceProxy::DataFlow::IODataPut* p) { return p; }

void
::IceProxy::DataFlow::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IODataPut>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::DataFlow::IODataPut;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::DataFlow::IODataPut::_newInstance() const
{
    return new IODataPut;
}

const ::std::string&
IceProxy::DataFlow::IODataPut::ice_staticId()
{
    return ::DataFlow::IODataPut::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::DataFlow::upCast(::IceProxy::DataFlow::IODataGet* p) { return p; }

void
::IceProxy::DataFlow::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IODataGet>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::DataFlow::IODataGet;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::DataFlow::IODataGet::_newInstance() const
{
    return new IODataGet;
}

const ::std::string&
IceProxy::DataFlow::IODataGet::ice_staticId()
{
    return ::DataFlow::IODataGet::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::DataFlow::upCast(::IceProxy::DataFlow::IOStreamParam* p) { return p; }

void
::IceProxy::DataFlow::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IOStreamParam>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::DataFlow::IOStreamParam;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::DataFlow::IOStreamParam::_newInstance() const
{
    return new IOStreamParam;
}

const ::std::string&
IceProxy::DataFlow::IOStreamParam::ice_staticId()
{
    return ::DataFlow::IOStreamParam::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::DataFlow::upCast(::IceProxy::DataFlow::IOStream* p) { return p; }

void
::IceProxy::DataFlow::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::IOStream>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::DataFlow::IOStream;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::DataFlow::IOStream::_newInstance() const
{
    return new IOStream;
}

const ::std::string&
IceProxy::DataFlow::IOStream::ice_staticId()
{
    return ::DataFlow::IOStream::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::DataFlow::upCast(::IceProxy::DataFlow::ObjectBase* p) { return p; }

void
::IceProxy::DataFlow::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::ObjectBase>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::DataFlow::ObjectBase;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::DataFlow::ObjectBase::_newInstance() const
{
    return new ObjectBase;
}

const ::std::string&
IceProxy::DataFlow::ObjectBase::ice_staticId()
{
    return ::DataFlow::ObjectBase::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::DataFlow::upCast(::IceProxy::DataFlow::InitServerParams* p) { return p; }

void
::IceProxy::DataFlow::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::InitServerParams>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::DataFlow::InitServerParams;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::DataFlow::InitServerParams::_newInstance() const
{
    return new InitServerParams;
}

const ::std::string&
IceProxy::DataFlow::InitServerParams::ice_staticId()
{
    return ::DataFlow::InitServerParams::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::DataFlow::upCast(::IceProxy::DataFlow::DSStatus* p) { return p; }

void
::IceProxy::DataFlow::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::DSStatus>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::DataFlow::DSStatus;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::DataFlow::DSStatus::_newInstance() const
{
    return new DSStatus;
}

const ::std::string&
IceProxy::DataFlow::DSStatus::ice_staticId()
{
    return ::DataFlow::DSStatus::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::DataFlow::upCast(::IceProxy::DataFlow::BatchDataProcessorStatus* p) { return p; }

void
::IceProxy::DataFlow::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::BatchDataProcessorStatus>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::DataFlow::BatchDataProcessorStatus;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::DataFlow::BatchDataProcessorStatus::_newInstance() const
{
    return new BatchDataProcessorStatus;
}

const ::std::string&
IceProxy::DataFlow::BatchDataProcessorStatus::ice_staticId()
{
    return ::DataFlow::BatchDataProcessorStatus::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::DataFlow::upCast(::IceProxy::DataFlow::DataServer* p) { return p; }

void
::IceProxy::DataFlow::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::DataServer>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::DataFlow::DataServer;
        v->_copyFrom(proxy);
    }
}

::Ice::AsyncResultPtr
IceProxy::DataFlow::DataServer::_iceI_begin_init(const ::DataFlow::InitServerParamsPtr& iceP_params, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_DataFlow_DataServer_init_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_DataFlow_DataServer_init_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_params);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_DataFlow_DataServer_init_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::DataFlow::DataServer::end_init(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_DataFlow_DataServer_init_name);
}

::Ice::AsyncResultPtr
IceProxy::DataFlow::DataServer::_iceI_begin_getStatus(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_DataFlow_DataServer_getStatus_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_DataFlow_DataServer_getStatus_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_DataFlow_DataServer_getStatus_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_DataFlow_DataServer_getStatus_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::DataFlow::DSStatusPtr
IceProxy::DataFlow::DataServer::end_getStatus(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_DataFlow_DataServer_getStatus_name);
    ::DataFlow::DSStatusPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::DataFlow::DataServer::_iceI_begin_getBatchDataProcessorStatus(const ::std::string& iceP_name, ::Ice::Int iceP_processorIdx, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_DataFlow_DataServer_getBatchDataProcessorStatus_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_DataFlow_DataServer_getBatchDataProcessorStatus_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_DataFlow_DataServer_getBatchDataProcessorStatus_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_processorIdx);
        result->endWriteParams();
        result->invoke(iceC_DataFlow_DataServer_getBatchDataProcessorStatus_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::DataFlow::BatchDataProcessorStatusPtr
IceProxy::DataFlow::DataServer::end_getBatchDataProcessorStatus(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_DataFlow_DataServer_getBatchDataProcessorStatus_name);
    ::DataFlow::BatchDataProcessorStatusPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::DataFlow::DataServer::_iceI_begin_putData(const ::DataFlow::IODataPutPtr& iceP_data, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_DataFlow_DataServer_putData_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_DataFlow_DataServer_putData_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_DataFlow_DataServer_putData_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_data);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_DataFlow_DataServer_putData_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::DataFlow::DataServer::end_putData(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_DataFlow_DataServer_putData_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::DataFlow::ExceptionClosed&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::DataFlow::DataServer::_iceI_begin_getData(const ::std::string& iceP_name, ::Ice::Int iceP_processorIdx, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_DataFlow_DataServer_getData_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_DataFlow_DataServer_getData_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_DataFlow_DataServer_getData_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_processorIdx);
        result->endWriteParams();
        result->invoke(iceC_DataFlow_DataServer_getData_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::DataFlow::IODataGetPtr
IceProxy::DataFlow::DataServer::end_getData(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_DataFlow_DataServer_getData_name);
    ::DataFlow::IODataGetPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::DataFlow::ExceptionClosed&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::IceProxy::Ice::Object*
IceProxy::DataFlow::DataServer::_newInstance() const
{
    return new DataServer;
}

const ::std::string&
IceProxy::DataFlow::DataServer::ice_staticId()
{
    return ::DataFlow::DataServer::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::DataFlow::upCast(::IceProxy::DataFlow::EvtEpoch* p) { return p; }

void
::IceProxy::DataFlow::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::EvtEpoch>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::DataFlow::EvtEpoch;
        v->_copyFrom(proxy);
    }
}

::IceProxy::Ice::Object*
IceProxy::DataFlow::EvtEpoch::_newInstance() const
{
    return new EvtEpoch;
}

const ::std::string&
IceProxy::DataFlow::EvtEpoch::ice_staticId()
{
    return ::DataFlow::EvtEpoch::ice_staticId();
}
::IceProxy::Ice::Object* ::IceProxy::DataFlow::upCast(::IceProxy::DataFlow::BatchDataProcessor* p) { return p; }

void
::IceProxy::DataFlow::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ::IceProxy::DataFlow::BatchDataProcessor>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::DataFlow::BatchDataProcessor;
        v->_copyFrom(proxy);
    }
}

::Ice::AsyncResultPtr
IceProxy::DataFlow::BatchDataProcessor::_iceI_begin_onEvent(const ::DataFlow::EventParamMap& iceP_params, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_DataFlow_BatchDataProcessor_onEvent_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_DataFlow_BatchDataProcessor_onEvent_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_params);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_DataFlow_BatchDataProcessor_onEvent_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::DataFlow::BatchDataProcessor::end_onEvent(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_DataFlow_BatchDataProcessor_onEvent_name);
}

::IceProxy::Ice::Object*
IceProxy::DataFlow::BatchDataProcessor::_newInstance() const
{
    return new BatchDataProcessor;
}

const ::std::string&
IceProxy::DataFlow::BatchDataProcessor::ice_staticId()
{
    return ::DataFlow::BatchDataProcessor::ice_staticId();
}

DataFlow::NDArray::~NDArray()
{
}

::Ice::Object* DataFlow::upCast(::DataFlow::NDArray* p) { return p; }

::Ice::ObjectPtr
DataFlow::NDArray::ice_clone() const
{
    ::Ice::Object* p = new NDArray(*this);
    return p;
}

namespace
{
const ::std::string iceC_DataFlow_NDArray_ids[2] =
{
    "::DataFlow::NDArray",
    "::Ice::Object"
};

}

bool
DataFlow::NDArray::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_NDArray_ids, iceC_DataFlow_NDArray_ids + 2, s);
}

::std::vector< ::std::string>
DataFlow::NDArray::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_DataFlow_NDArray_ids[0], &iceC_DataFlow_NDArray_ids[2]);
}

const ::std::string&
DataFlow::NDArray::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::NDArray::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::DataFlow::NDArray";
    return typeId;
#else
    return iceC_DataFlow_NDArray_ids[0];
#endif
}

void
DataFlow::NDArray::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::DataFlow::NDArray, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
DataFlow::NDArray::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::DataFlow::NDArray, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::DataFlow::NDArray> iceC_DataFlow_NDArray_init("::DataFlow::NDArray");
}

::Ice::ValueFactoryPtr
DataFlow::NDArray::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::DataFlow::NDArray::ice_staticId());
}

void
DataFlow::_icePatchObjectPtr(NDArrayPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::DataFlow::NDArrayPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::DataFlow::NDArray::ice_staticId(), v);
    }
}

DataFlow::IOData::~IOData()
{
}

::Ice::Object* DataFlow::upCast(::DataFlow::IOData* p) { return p; }


#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
DataFlow::IOData::ice_clone() const
{
    ::Ice::Object* p = new IOData(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_DataFlow_IOData_ids[2] =
{
    "::DataFlow::IOData",
    "::Ice::Object"
};

}

bool
DataFlow::IOData::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_IOData_ids, iceC_DataFlow_IOData_ids + 2, s);
}

::std::vector< ::std::string>
DataFlow::IOData::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_DataFlow_IOData_ids[0], &iceC_DataFlow_IOData_ids[2]);
}

const ::std::string&
DataFlow::IOData::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::IOData::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::DataFlow::IOData";
    return typeId;
#else
    return iceC_DataFlow_IOData_ids[0];
#endif
}

void
DataFlow::IOData::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    {
        for(::DataFlow::NDArrayList::iterator _i0 = datas.begin(); _i0 != datas.end(); ++_i0)
        {
            if((*_i0))
            {
                if((::DataFlow::upCast((*_i0).get())->_iceGcVisit(v_)))
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

void
DataFlow::IOData::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::DataFlow::IOData, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
DataFlow::IOData::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::DataFlow::IOData, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::DataFlow::IOData> iceC_DataFlow_IOData_init("::DataFlow::IOData");
}

::Ice::ValueFactoryPtr
DataFlow::IOData::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::DataFlow::IOData::ice_staticId());
}

void
DataFlow::_icePatchObjectPtr(IODataPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::DataFlow::IODataPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::DataFlow::IOData::ice_staticId(), v);
    }
}

DataFlow::IODataPut::~IODataPut()
{
}

::Ice::Object* DataFlow::upCast(::DataFlow::IODataPut* p) { return p; }

::Ice::ObjectPtr
DataFlow::IODataPut::ice_clone() const
{
    ::Ice::Object* p = new IODataPut(*this);
    return p;
}

namespace
{
const ::std::string iceC_DataFlow_IODataPut_ids[3] =
{
    "::DataFlow::IOData",
    "::DataFlow::IODataPut",
    "::Ice::Object"
};

}

bool
DataFlow::IODataPut::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_IODataPut_ids, iceC_DataFlow_IODataPut_ids + 3, s);
}

::std::vector< ::std::string>
DataFlow::IODataPut::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_DataFlow_IODataPut_ids[0], &iceC_DataFlow_IODataPut_ids[3]);
}

const ::std::string&
DataFlow::IODataPut::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::IODataPut::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::DataFlow::IODataPut";
    return typeId;
#else
    return iceC_DataFlow_IODataPut_ids[1];
#endif
}

void
DataFlow::IODataPut::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    ::DataFlow::IOData::_iceGcVisitMembers(v_);
}

void
DataFlow::IODataPut::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    Ice::StreamWriter< ::DataFlow::IODataPut, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    ::DataFlow::IOData::_iceWriteImpl(ostr);
}

void
DataFlow::IODataPut::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::DataFlow::IODataPut, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    ::DataFlow::IOData::_iceReadImpl(istr);
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::DataFlow::IODataPut> iceC_DataFlow_IODataPut_init("::DataFlow::IODataPut");
}

::Ice::ValueFactoryPtr
DataFlow::IODataPut::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::DataFlow::IODataPut::ice_staticId());
}

void
DataFlow::_icePatchObjectPtr(IODataPutPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::DataFlow::IODataPutPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::DataFlow::IODataPut::ice_staticId(), v);
    }
}

DataFlow::IODataGet::~IODataGet()
{
}

::Ice::Object* DataFlow::upCast(::DataFlow::IODataGet* p) { return p; }

::Ice::ObjectPtr
DataFlow::IODataGet::ice_clone() const
{
    ::Ice::Object* p = new IODataGet(*this);
    return p;
}

namespace
{
const ::std::string iceC_DataFlow_IODataGet_ids[3] =
{
    "::DataFlow::IOData",
    "::DataFlow::IODataGet",
    "::Ice::Object"
};

}

bool
DataFlow::IODataGet::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_IODataGet_ids, iceC_DataFlow_IODataGet_ids + 3, s);
}

::std::vector< ::std::string>
DataFlow::IODataGet::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_DataFlow_IODataGet_ids[0], &iceC_DataFlow_IODataGet_ids[3]);
}

const ::std::string&
DataFlow::IODataGet::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::IODataGet::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::DataFlow::IODataGet";
    return typeId;
#else
    return iceC_DataFlow_IODataGet_ids[1];
#endif
}

void
DataFlow::IODataGet::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    ::DataFlow::IOData::_iceGcVisitMembers(v_);
}

void
DataFlow::IODataGet::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    Ice::StreamWriter< ::DataFlow::IODataGet, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    ::DataFlow::IOData::_iceWriteImpl(ostr);
}

void
DataFlow::IODataGet::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::DataFlow::IODataGet, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    ::DataFlow::IOData::_iceReadImpl(istr);
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::DataFlow::IODataGet> iceC_DataFlow_IODataGet_init("::DataFlow::IODataGet");
}

::Ice::ValueFactoryPtr
DataFlow::IODataGet::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::DataFlow::IODataGet::ice_staticId());
}

void
DataFlow::_icePatchObjectPtr(IODataGetPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::DataFlow::IODataGetPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::DataFlow::IODataGet::ice_staticId(), v);
    }
}

DataFlow::IOStreamParam::~IOStreamParam()
{
}

::Ice::Object* DataFlow::upCast(::DataFlow::IOStreamParam* p) { return p; }

::Ice::ObjectPtr
DataFlow::IOStreamParam::ice_clone() const
{
    ::Ice::Object* p = new IOStreamParam(*this);
    return p;
}

namespace
{
const ::std::string iceC_DataFlow_IOStreamParam_ids[2] =
{
    "::DataFlow::IOStreamParam",
    "::Ice::Object"
};

}

bool
DataFlow::IOStreamParam::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_IOStreamParam_ids, iceC_DataFlow_IOStreamParam_ids + 2, s);
}

::std::vector< ::std::string>
DataFlow::IOStreamParam::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_DataFlow_IOStreamParam_ids[0], &iceC_DataFlow_IOStreamParam_ids[2]);
}

const ::std::string&
DataFlow::IOStreamParam::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::IOStreamParam::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::DataFlow::IOStreamParam";
    return typeId;
#else
    return iceC_DataFlow_IOStreamParam_ids[0];
#endif
}

void
DataFlow::IOStreamParam::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::DataFlow::IOStreamParam, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
DataFlow::IOStreamParam::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::DataFlow::IOStreamParam, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::DataFlow::IOStreamParam> iceC_DataFlow_IOStreamParam_init("::DataFlow::IOStreamParam");
}

::Ice::ValueFactoryPtr
DataFlow::IOStreamParam::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::DataFlow::IOStreamParam::ice_staticId());
}

void
DataFlow::_icePatchObjectPtr(IOStreamParamPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::DataFlow::IOStreamParamPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::DataFlow::IOStreamParam::ice_staticId(), v);
    }
}

DataFlow::IOStream::~IOStream()
{
}

::Ice::Object* DataFlow::upCast(::DataFlow::IOStream* p) { return p; }


namespace
{
const ::std::string iceC_DataFlow_IOStream_ids[2] =
{
    "::DataFlow::IOStream",
    "::Ice::Object"
};

}

bool
DataFlow::IOStream::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_IOStream_ids, iceC_DataFlow_IOStream_ids + 2, s);
}

::std::vector< ::std::string>
DataFlow::IOStream::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_DataFlow_IOStream_ids[0], &iceC_DataFlow_IOStream_ids[2]);
}

const ::std::string&
DataFlow::IOStream::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::IOStream::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::DataFlow::IOStream";
    return typeId;
#else
    return iceC_DataFlow_IOStream_ids[0];
#endif
}

void
DataFlow::IOStream::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::DataFlow::IOStream, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
DataFlow::IOStream::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::DataFlow::IOStream, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

void
DataFlow::_icePatchObjectPtr(IOStreamPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::DataFlow::IOStreamPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::DataFlow::IOStream::ice_staticId(), v);
    }
}

DataFlow::ObjectBase::~ObjectBase()
{
}

::Ice::Object* DataFlow::upCast(::DataFlow::ObjectBase* p) { return p; }

::Ice::ObjectPtr
DataFlow::ObjectBase::ice_clone() const
{
    ::Ice::Object* p = new ObjectBase(*this);
    return p;
}

namespace
{
const ::std::string iceC_DataFlow_ObjectBase_ids[2] =
{
    "::DataFlow::ObjectBase",
    "::Ice::Object"
};

}

bool
DataFlow::ObjectBase::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_ObjectBase_ids, iceC_DataFlow_ObjectBase_ids + 2, s);
}

::std::vector< ::std::string>
DataFlow::ObjectBase::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_DataFlow_ObjectBase_ids[0], &iceC_DataFlow_ObjectBase_ids[2]);
}

const ::std::string&
DataFlow::ObjectBase::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::ObjectBase::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::DataFlow::ObjectBase";
    return typeId;
#else
    return iceC_DataFlow_ObjectBase_ids[0];
#endif
}

void
DataFlow::ObjectBase::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::DataFlow::ObjectBase, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
DataFlow::ObjectBase::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::DataFlow::ObjectBase, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::DataFlow::ObjectBase> iceC_DataFlow_ObjectBase_init("::DataFlow::ObjectBase");
}

::Ice::ValueFactoryPtr
DataFlow::ObjectBase::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::DataFlow::ObjectBase::ice_staticId());
}

void
DataFlow::_icePatchObjectPtr(ObjectBasePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::DataFlow::ObjectBasePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::DataFlow::ObjectBase::ice_staticId(), v);
    }
}

DataFlow::InitServerParams::~InitServerParams()
{
}

::Ice::Object* DataFlow::upCast(::DataFlow::InitServerParams* p) { return p; }

::Ice::ObjectPtr
DataFlow::InitServerParams::ice_clone() const
{
    ::Ice::Object* p = new InitServerParams(*this);
    return p;
}

namespace
{
const ::std::string iceC_DataFlow_InitServerParams_ids[2] =
{
    "::DataFlow::InitServerParams",
    "::Ice::Object"
};

}

bool
DataFlow::InitServerParams::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_InitServerParams_ids, iceC_DataFlow_InitServerParams_ids + 2, s);
}

::std::vector< ::std::string>
DataFlow::InitServerParams::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_DataFlow_InitServerParams_ids[0], &iceC_DataFlow_InitServerParams_ids[2]);
}

const ::std::string&
DataFlow::InitServerParams::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::InitServerParams::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::DataFlow::InitServerParams";
    return typeId;
#else
    return iceC_DataFlow_InitServerParams_ids[0];
#endif
}

void
DataFlow::InitServerParams::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::DataFlow::InitServerParams, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
DataFlow::InitServerParams::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::DataFlow::InitServerParams, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::DataFlow::InitServerParams> iceC_DataFlow_InitServerParams_init("::DataFlow::InitServerParams");
}

::Ice::ValueFactoryPtr
DataFlow::InitServerParams::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::DataFlow::InitServerParams::ice_staticId());
}

void
DataFlow::_icePatchObjectPtr(InitServerParamsPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::DataFlow::InitServerParamsPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::DataFlow::InitServerParams::ice_staticId(), v);
    }
}

DataFlow::DSStatus::~DSStatus()
{
}

::Ice::Object* DataFlow::upCast(::DataFlow::DSStatus* p) { return p; }

::Ice::ObjectPtr
DataFlow::DSStatus::ice_clone() const
{
    ::Ice::Object* p = new DSStatus(*this);
    return p;
}

namespace
{
const ::std::string iceC_DataFlow_DSStatus_ids[2] =
{
    "::DataFlow::DSStatus",
    "::Ice::Object"
};

}

bool
DataFlow::DSStatus::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_DSStatus_ids, iceC_DataFlow_DSStatus_ids + 2, s);
}

::std::vector< ::std::string>
DataFlow::DSStatus::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_DataFlow_DSStatus_ids[0], &iceC_DataFlow_DSStatus_ids[2]);
}

const ::std::string&
DataFlow::DSStatus::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::DSStatus::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::DataFlow::DSStatus";
    return typeId;
#else
    return iceC_DataFlow_DSStatus_ids[0];
#endif
}

void
DataFlow::DSStatus::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::DataFlow::DSStatus, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
DataFlow::DSStatus::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::DataFlow::DSStatus, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::DataFlow::DSStatus> iceC_DataFlow_DSStatus_init("::DataFlow::DSStatus");
}

::Ice::ValueFactoryPtr
DataFlow::DSStatus::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::DataFlow::DSStatus::ice_staticId());
}

void
DataFlow::_icePatchObjectPtr(DSStatusPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::DataFlow::DSStatusPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::DataFlow::DSStatus::ice_staticId(), v);
    }
}

DataFlow::BatchDataProcessorStatus::~BatchDataProcessorStatus()
{
}

::Ice::Object* DataFlow::upCast(::DataFlow::BatchDataProcessorStatus* p) { return p; }

::Ice::ObjectPtr
DataFlow::BatchDataProcessorStatus::ice_clone() const
{
    ::Ice::Object* p = new BatchDataProcessorStatus(*this);
    return p;
}

namespace
{
const ::std::string iceC_DataFlow_BatchDataProcessorStatus_ids[2] =
{
    "::DataFlow::BatchDataProcessorStatus",
    "::Ice::Object"
};

}

bool
DataFlow::BatchDataProcessorStatus::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_BatchDataProcessorStatus_ids, iceC_DataFlow_BatchDataProcessorStatus_ids + 2, s);
}

::std::vector< ::std::string>
DataFlow::BatchDataProcessorStatus::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_DataFlow_BatchDataProcessorStatus_ids[0], &iceC_DataFlow_BatchDataProcessorStatus_ids[2]);
}

const ::std::string&
DataFlow::BatchDataProcessorStatus::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::BatchDataProcessorStatus::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::DataFlow::BatchDataProcessorStatus";
    return typeId;
#else
    return iceC_DataFlow_BatchDataProcessorStatus_ids[0];
#endif
}

void
DataFlow::BatchDataProcessorStatus::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::DataFlow::BatchDataProcessorStatus, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
DataFlow::BatchDataProcessorStatus::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::DataFlow::BatchDataProcessorStatus, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::DataFlow::BatchDataProcessorStatus> iceC_DataFlow_BatchDataProcessorStatus_init("::DataFlow::BatchDataProcessorStatus");
}

::Ice::ValueFactoryPtr
DataFlow::BatchDataProcessorStatus::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::DataFlow::BatchDataProcessorStatus::ice_staticId());
}

void
DataFlow::_icePatchObjectPtr(BatchDataProcessorStatusPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::DataFlow::BatchDataProcessorStatusPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::DataFlow::BatchDataProcessorStatus::ice_staticId(), v);
    }
}

DataFlow::DataServer::~DataServer()
{
}

::Ice::Object* DataFlow::upCast(::DataFlow::DataServer* p) { return p; }


namespace
{
const ::std::string iceC_DataFlow_DataServer_ids[2] =
{
    "::DataFlow::DataServer",
    "::Ice::Object"
};

}

bool
DataFlow::DataServer::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_DataServer_ids, iceC_DataFlow_DataServer_ids + 2, s);
}

::std::vector< ::std::string>
DataFlow::DataServer::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_DataFlow_DataServer_ids[0], &iceC_DataFlow_DataServer_ids[2]);
}

const ::std::string&
DataFlow::DataServer::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::DataServer::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::DataFlow::DataServer";
    return typeId;
#else
    return iceC_DataFlow_DataServer_ids[0];
#endif
}

bool
DataFlow::DataServer::_iceD_init(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::DataFlow::InitServerParamsPtr iceP_params;
    istr->read(iceP_params);
    istr->readPendingValues();
    inS.endReadParams();
    this->init(iceP_params, current);
    inS.writeEmptyParams();
    return true;
}

bool
DataFlow::DataServer::_iceD_getStatus(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::DataFlow::DSStatusPtr ret = this->getStatus(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}

bool
DataFlow::DataServer::_iceD_getBatchDataProcessorStatus(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::Ice::Int iceP_processorIdx;
    istr->read(iceP_name);
    istr->read(iceP_processorIdx);
    inS.endReadParams();
    ::DataFlow::BatchDataProcessorStatusPtr ret = this->getBatchDataProcessorStatus(iceP_name, iceP_processorIdx, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}

bool
DataFlow::DataServer::_iceD_putData(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::DataFlow::IODataPutPtr iceP_data;
    istr->read(iceP_data);
    istr->readPendingValues();
    inS.endReadParams();
    this->putData(iceP_data, current);
    inS.writeEmptyParams();
    return true;
}

bool
DataFlow::DataServer::_iceD_getData(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::Ice::Int iceP_processorIdx;
    istr->read(iceP_name);
    istr->read(iceP_processorIdx);
    inS.endReadParams();
    ::DataFlow::IODataGetPtr ret = this->getData(iceP_name, iceP_processorIdx, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}

namespace
{
const ::std::string iceC_DataFlow_DataServer_all[] =
{
    "getBatchDataProcessorStatus",
    "getData",
    "getStatus",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "init",
    "putData"
};

}

bool
DataFlow::DataServer::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_DataFlow_DataServer_all, iceC_DataFlow_DataServer_all + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_DataFlow_DataServer_all)
    {
        case 0:
        {
            return _iceD_getBatchDataProcessorStatus(in, current);
        }
        case 1:
        {
            return _iceD_getData(in, current);
        }
        case 2:
        {
            return _iceD_getStatus(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_init(in, current);
        }
        case 8:
        {
            return _iceD_putData(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}

void
DataFlow::DataServer::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::DataFlow::DataServer, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
DataFlow::DataServer::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::DataFlow::DataServer, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

void
DataFlow::_icePatchObjectPtr(DataServerPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::DataFlow::DataServerPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::DataFlow::DataServer::ice_staticId(), v);
    }
}

DataFlow::EvtEpoch::~EvtEpoch()
{
}

::Ice::Object* DataFlow::upCast(::DataFlow::EvtEpoch* p) { return p; }

::Ice::ObjectPtr
DataFlow::EvtEpoch::ice_clone() const
{
    ::Ice::Object* p = new EvtEpoch(*this);
    return p;
}

namespace
{
const ::std::string iceC_DataFlow_EvtEpoch_ids[3] =
{
    "::DataFlow::EvtEpoch",
    "::DataFlow::ObjectBase",
    "::Ice::Object"
};

}

bool
DataFlow::EvtEpoch::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_EvtEpoch_ids, iceC_DataFlow_EvtEpoch_ids + 3, s);
}

::std::vector< ::std::string>
DataFlow::EvtEpoch::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_DataFlow_EvtEpoch_ids[0], &iceC_DataFlow_EvtEpoch_ids[3]);
}

const ::std::string&
DataFlow::EvtEpoch::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::EvtEpoch::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::DataFlow::EvtEpoch";
    return typeId;
#else
    return iceC_DataFlow_EvtEpoch_ids[0];
#endif
}

void
DataFlow::EvtEpoch::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    Ice::StreamWriter< ::DataFlow::EvtEpoch, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    ::DataFlow::ObjectBase::_iceWriteImpl(ostr);
}

void
DataFlow::EvtEpoch::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::DataFlow::EvtEpoch, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    ::DataFlow::ObjectBase::_iceReadImpl(istr);
}

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::DataFlow::EvtEpoch> iceC_DataFlow_EvtEpoch_init("::DataFlow::EvtEpoch");
}

::Ice::ValueFactoryPtr
DataFlow::EvtEpoch::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::DataFlow::EvtEpoch::ice_staticId());
}

void
DataFlow::_icePatchObjectPtr(EvtEpochPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::DataFlow::EvtEpochPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::DataFlow::EvtEpoch::ice_staticId(), v);
    }
}

DataFlow::BatchDataProcessor::~BatchDataProcessor()
{
}

::Ice::Object* DataFlow::upCast(::DataFlow::BatchDataProcessor* p) { return p; }


namespace
{
const ::std::string iceC_DataFlow_BatchDataProcessor_ids[2] =
{
    "::DataFlow::BatchDataProcessor",
    "::Ice::Object"
};

}

bool
DataFlow::BatchDataProcessor::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_DataFlow_BatchDataProcessor_ids, iceC_DataFlow_BatchDataProcessor_ids + 2, s);
}

::std::vector< ::std::string>
DataFlow::BatchDataProcessor::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_DataFlow_BatchDataProcessor_ids[0], &iceC_DataFlow_BatchDataProcessor_ids[2]);
}

const ::std::string&
DataFlow::BatchDataProcessor::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
DataFlow::BatchDataProcessor::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::DataFlow::BatchDataProcessor";
    return typeId;
#else
    return iceC_DataFlow_BatchDataProcessor_ids[0];
#endif
}

bool
DataFlow::BatchDataProcessor::_iceD_onEvent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::DataFlow::EventParamMap iceP_params;
    istr->read(iceP_params);
    istr->readPendingValues();
    inS.endReadParams();
    this->onEvent(iceP_params, current);
    inS.writeEmptyParams();
    return true;
}

namespace
{
const ::std::string iceC_DataFlow_BatchDataProcessor_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "onEvent"
};

}

bool
DataFlow::BatchDataProcessor::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_DataFlow_BatchDataProcessor_all, iceC_DataFlow_BatchDataProcessor_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_DataFlow_BatchDataProcessor_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_onEvent(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}

void
DataFlow::BatchDataProcessor::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    Ice::StreamWriter< ::DataFlow::BatchDataProcessor, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
DataFlow::BatchDataProcessor::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    Ice::StreamReader< ::DataFlow::BatchDataProcessor, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}

void
DataFlow::_icePatchObjectPtr(BatchDataProcessorPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::DataFlow::BatchDataProcessorPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::DataFlow::BatchDataProcessor::ice_staticId(), v);
    }
}

namespace Ice
{
}

#endif
